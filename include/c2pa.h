// Copyright 2023 Adobe. All rights reserved.
// This file is licensed to you under the Apache License,
// Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
// or the MIT license (http://opensource.org/licenses/MIT),
// at your option.

// Unless required by applicable law or agreed to in writing,
// this software is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or
// implied. See the LICENSE-MIT and LICENSE-APACHE files for the
// specific language governing permissions and limitations under
// each license.

// This file is generated by cbindgen, do not edit by hand.

#ifndef c2pa_bindings_h
#define c2pa_bindings_h

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#if defined(_WIN32) || defined(_WIN64)
    #if defined(_STATIC_C2PA) 
        #define IMPORT  __declspec(dllexport)
    #else 
        #if __GNUC__
            #define IMPORT __attribute__ ((dllimport))
        #else
            #define IMPORT __declspec(dllimport)
        #endif
    #endif
#else
    #define IMPORT

#endif

typedef struct ManifestStore ManifestStore;


typedef struct C2paSigner C2paSigner;

/**
 * An Opaque struct to hold a context value for the stream callbacks
 */
typedef struct StreamContext {

} StreamContext;

/**
 * Defines a callback to read from a stream
 */
typedef intptr_t (*ReadCallback)(const struct StreamContext *context, uint8_t *data, uintptr_t len);

/**
 * Defines a callback to seek to an offset in a stream
 */
typedef int (*SeekCallback)(const struct StreamContext *context, long offset, int mode);

/**
 * Defines a callback to write to a stream
 */
typedef intptr_t (*WriteCallback)(const struct StreamContext *context,
                                  const uint8_t *data,
                                  uintptr_t len);

typedef intptr_t (*FlushCallback)(const struct StreamContext *context);

/**
 * A CStream is a Rust Read/Write/Seek stream that can be created in C
 */
typedef struct CStream {
  struct StreamContext *context;
  ReadCallback reader;
  SeekCallback seeker;
  WriteCallback writer;
  FlushCallback flusher;
} CStream;

/**
 * Defines the configuration for a Signer
 *
 * The signer is created from the signcert and pkey fields.
 * an optional url to an RFC 3161 compliant time server will ensure the signature is timestamped
 *
 */
typedef struct C2paSignerInfo {
  /**
   * The signing algorithm
   */
  const char *alg;
  /**
   * The public certificate chain in PEM format
   */
  const char *sign_cert;
  /**
   * The private key in PEM format
   */
  const char *private_key;
  /**
   * The timestamp authority URL or NULL
   */
  const char *ta_url;
} C2paSignerInfo;

/**
 * Defines a callback to sign data
 */
typedef intptr_t (*CSignerCallback)(uint8_t *data,
                                    uintptr_t len,
                                    uint8_t *signature,
                                    intptr_t sig_max_size);

/**
 * Defines the configuration for a Signer
 *
 * # Example
 * ```
 * use c2pa::SignerConfig;
 * let config = SignerConfig {
 *    alg: "Rs256".to_string(),
 *    certs: vec![vec![0; 10]],
 *    time_authority_url: Some("http://example.com".to_string()),
 *    use_ocsp: true,
 * };
 */
typedef struct CSignerConfig {
  /**
   * Returns the algorithm of the Signer.
   */
  const char *alg;
  /**
   * Returns the certificates as a Vec containing a Vec of DER bytes for each certificate.
   */
  const char *certs;
  /**
   * URL for time authority to time stamp the signature
   */
  const char *time_authority_url;
  /**
   * Try to fetch OCSP response for the signing cert if available
   */
  bool use_ocsp;
} CSignerConfig;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Returns a version string for logging
 *
 * # Safety
 * The returned value MUST be released by calling release_string
 * and it is no longer valid after that call.
 */
IMPORT extern char *c2pa_version(void);

/**
 * Returns the last error message
 *
 * # Safety
 * The returned value MUST be released by calling release_string
 * and it is no longer valid after that call.
 */
IMPORT extern char *c2pa_error(void);

IMPORT extern
ManifestStore *c2pa_manifest_store_from_stream(const char *format,
                                               struct CStream *stream);

IMPORT extern char *c2pa_manifest_store_json(ManifestStore **store_ptr);

/**
 * Returns a ManifestStore JSON string from a file path.
 * Any thumbnails or other binary resources will be written to data_dir if provided
 *
 * # Errors
 * Returns NULL if there were errors, otherwise returns a JSON string
 * The error string can be retrieved by calling c2pa_error
 *
 * # Safety
 * Reads from null terminated C strings
 * The returned value MUST be released by calling release_string
 * and it is no longer valid after that call.
 */
IMPORT extern char *c2pa_read_file(const char *path, const char *data_dir);

/**
 * Returns an Ingredient JSON string from a file path.
 * Any thumbnail or c2pa data will be written to data_dir if provided
 *
 * # Errors
 * Returns NULL if there were errors, otherwise returns a JSON string
 * containing the Ingredient
 * The error string can be retrieved by calling c2pa_error
 *
 * # Safety
 * Reads from null terminated C strings
 * The returned value MUST be released by calling release_string
 * and it is no longer valid after that call.
 */
IMPORT extern char *c2pa_read_ingredient_file(const char *path, const char *data_dir);

/**
 * Add a signed manifest to the file at path using auth_token
 * If cloud is true, upload the manifest to the cloud
 *
 * # Errors
 * Returns an error field if there were errors
 *
 * # Safety
 * Reads from null terminated C strings
 * The returned value MUST be released by calling release_string
 * and it is no longer valid after that call.
 */
IMPORT extern
char *c2pa_sign_file(const char *source_path,
                     const char *dest_path,
                     const char *manifest,
                     const struct C2paSignerInfo *signer_info,
                     const char *data_dir);

/**
 * Releases a ManifestStore allocated by Rust
 *
 * # Safety
 * can only be released once and is invalid after this call
 */
IMPORT extern void c2pa_release_manifest_store(ManifestStore *store);

/**
 * Releases a string allocated by Rust
 *
 * # Safety
 * Reads from null terminated C strings
 * The string must not have been modified in C
 * can only be released once and is invalid after this call
 */
IMPORT extern void c2pa_release_string(char *s);

IMPORT extern
struct C2paSigner *c2pa_create_signer(CSignerCallback signer,
                                      const struct CSignerConfig *config);

/**
 * Creates a new C2paStream from context with callbacks
 *
 * This allows implementing streams in other languages
 *
 * # Arguments
 * * `context` - a pointer to a StreamContext
 * * `read` - a ReadCallback to read from the stream
 * * `seek` - a SeekCallback to seek in the stream
 * * `write` - a WriteCallback to write to the stream
 *
 * # Safety
 * The context must remain valid for the lifetime of the C2paStream
 * The resulting C2paStream must be released by calling c2pa_release_stream
 *
 */
IMPORT extern
struct CStream *c2pa_create_stream(struct StreamContext *context,
                                   ReadCallback reader,
                                   SeekCallback seeker,
                                   WriteCallback writer,
                                   FlushCallback flusher);

/**
 * Releases a CStream allocated by Rust
 *
 * # Safety
 * can only be released once and is invalid after this call
 */
IMPORT extern void c2pa_release_stream(struct CStream *stream);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* c2pa_bindings_h */
