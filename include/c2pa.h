// Copyright 2023 Adobe. All rights reserved.
// This file is licensed to you under the Apache License,
// Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
// or the MIT license (http://opensource.org/licenses/MIT),
// at your option.

// Unless required by applicable law or agreed to in writing,
// this software is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR REPRESENTATIONS OF ANY KIND, either express or
// implied. See the LICENSE-MIT and LICENSE-APACHE files for the
// specific language governing permissions and limitations under
// each license.

// This file is generated by cbindgen, do not edit by hand.

#ifndef c2pa_bindings_h
#define c2pa_bindings_h

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#if defined(_WIN32) || defined(_WIN64)
    #if defined(_STATIC_C2PA) 
        #define IMPORT  __declspec(dllexport)
    #else 
        #if __GNUC__
            #define IMPORT __attribute__ ((dllimport))
        #else
            #define IMPORT __declspec(dllimport)
        #endif
    #endif
#else
    #define IMPORT

#endif
typedef struct C2paReader C2paReader;
typedef struct C2paBuilder C2paBuilder;


typedef struct C2paSigner C2paSigner;

/**
 * Defines the configuration for a Signer
 *
 * The signer is created from the signcert and pkey fields.
 * an optional url to an RFC 3161 compliant time server will ensure the signature is timestamped
 *
 */
typedef struct C2paSignerInfo {
  /**
   * The signing algorithm
   */
  const char *alg;
  /**
   * The public certificate chain in PEM format
   */
  const char *sign_cert;
  /**
   * The private key in PEM format
   */
  const char *private_key;
  /**
   * The timestamp authority URL or NULL
   */
  const char *ta_url;
} C2paSignerInfo;

/**
 * An Opaque struct to hold a context value for the stream callbacks
 */
typedef struct StreamContext {

} StreamContext;

/**
 * Defines a callback to read from a stream
 */
typedef intptr_t (*ReadCallback)(const struct StreamContext *context, uint8_t *data, uintptr_t len);

/**
 * Defines a callback to seek to an offset in a stream
 */
typedef int (*SeekCallback)(const struct StreamContext *context, long offset, int mode);

/**
 * Defines a callback to write to a stream
 */
typedef intptr_t (*WriteCallback)(const struct StreamContext *context,
                                  const uint8_t *data,
                                  uintptr_t len);

typedef intptr_t (*FlushCallback)(const struct StreamContext *context);

/**
 * A CStream is a Rust Read/Write/Seek stream that can be created in C
 */
typedef struct CStream {
  struct StreamContext *context;
  ReadCallback reader;
  SeekCallback seeker;
  WriteCallback writer;
  FlushCallback flusher;
} CStream;

/**
 * Defines a callback to sign data
 */
typedef intptr_t (*CSignerCallback)(uint8_t *data,
                                    uintptr_t len,
                                    uint8_t *signature,
                                    intptr_t sig_max_size);

/**
 * Defines the configuration for a Signer
 *
 * # Example
 * ```
 * use c2pa::SignerConfig;
 * let config = SignerConfig {
 *    alg: "Rs256".to_string(),
 *    certs: vec![vec![0; 10]],
 *    time_authority_url: Some("http://example.com".to_string()),
 *    use_ocsp: true,
 * };
 */
typedef struct CSignerConfig {
  /**
   * Returns the algorithm of the Signer.
   */
  const char *alg;
  /**
   * Returns the certificates as a Vec containing a Vec of DER bytes for each certificate.
   */
  const char *certs;
  /**
   * URL for time authority to time stamp the signature
   */
  const char *time_authority_url;
  /**
   * Try to fetch OCSP response for the signing cert if available
   */
  bool use_ocsp;
} CSignerConfig;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Returns a version string for logging
 *
 * # Safety
 * The returned value MUST be released by calling release_string
 * and it is no longer valid after that call.
 */
IMPORT extern char *c2pa_version(void);

/**
 * Returns the last error message
 *
 * # Safety
 * The returned value MUST be released by calling release_string
 * and it is no longer valid after that call.
 */
IMPORT extern char *c2pa_error(void);

/**
 * Returns a ManifestStore JSON string from a file path.
 * Any thumbnails or other binary resources will be written to data_dir if provided
 *
 * # Errors
 * Returns NULL if there were errors, otherwise returns a JSON string
 * The error string can be retrieved by calling c2pa_error
 *
 * # Safety
 * Reads from null terminated C strings
 * The returned value MUST be released by calling release_string
 * and it is no longer valid after that call.
 */
IMPORT extern char *c2pa_read_file(const char *path, const char *data_dir);

/**
 * Returns an Ingredient JSON string from a file path.
 * Any thumbnail or c2pa data will be written to data_dir if provided
 *
 * # Errors
 * Returns NULL if there were errors, otherwise returns a JSON string
 * containing the Ingredient
 * The error string can be retrieved by calling c2pa_error
 *
 * # Safety
 * Reads from null terminated C strings
 * The returned value MUST be released by calling release_string
 * and it is no longer valid after that call.
 */
IMPORT extern char *c2pa_read_ingredient_file(const char *path, const char *data_dir);

/**
 * Add a signed manifest to the file at path using auth_token
 * If cloud is true, upload the manifest to the cloud
 *
 * # Errors
 * Returns an error field if there were errors
 *
 * # Safety
 * Reads from null terminated C strings
 * The returned value MUST be released by calling release_string
 * and it is no longer valid after that call.
 */
IMPORT extern
char *c2pa_sign_file(const char *source_path,
                     const char *dest_path,
                     const char *manifest,
                     const struct C2paSignerInfo *signer_info,
                     const char *data_dir);

/**
 * Releases a C2paBuilder allocated by Rust
 *
 * # Safety
 * can only be released once and is invalid after this call
 */
IMPORT extern void c2pa_release_builder(C2paBuilder *builder);

/**
 * Releases a string allocated by Rust
 *
 * # Safety
 * Reads from null terminated C strings
 * The string must not have been modified in C
 * can only be released once and is invalid after this call
 */
IMPORT extern void c2pa_release_string(char *s);

/**
 * Creates a C2paReader from an asset stream with the given format
 * # Errors
 * Returns NULL if there were errors, otherwise returns a pointer to a ManifestStore
 * The error string can be retrieved by calling c2pa_error
 * # Safety
 * Reads from null terminated C strings
 * The returned value MUST be released by calling c2pa_release__reader
 * and it is no longer valid after that call.
 * # Example
 * ```c
 * auto result = c2pa_read("image/jpeg", stream);
 * if (result == NULL) {
 *   printf("Error: %s\n", c2pa_error());
 * }
 * ```
 */
IMPORT extern C2paReader *c2pa_read(const char *format, struct CStream *stream);

/**
 * Releases a C2paReader allocated by Rust
 * # Safety
 * can only be released once and is invalid after this call
 */
IMPORT extern void c2pa_release_reader(C2paReader *reader_ptr);

/**
 * Returns a JSON string generated from a C2paReader
 */
IMPORT extern char *c2pa_reader_json(C2paReader *reader_ptr);

/**
 * writes a C2paReader resource to a stream given a uri
 * # Errors
 * Returns -1 if there were errors, otherwise returns size of stream written
 *
 * # Safety
 * Reads from null terminated C strings
 *
 * # Example
 * ```c
 * result c2pa_reader_resource(store, "uri", stream);
 * if (result < 0) {
 *    printf("Error: %s\n", c2pa_error());
 * }
 * ```
 */
IMPORT extern
int c2pa_reader_resource(C2paReader *reader_ptr,
                         const char *uri,
                         struct CStream *stream);

/**
 * Creates a C2paBuilder from a JSON manifest definition string
 * # Errors
 * Returns NULL if there were errors, otherwise returns a pointer to a Builder
 * The error string can be retrieved by calling c2pa_error
 * # Safety
 * Reads from null terminated C strings
 * The returned value MUST be released by calling c2pa_builder_release
 * and it is no longer valid after that call.
 * # Example
 * ```c
 * auto result = c2pa_manifest_store_builder_from_json(manifest_json);
 * if (result == NULL) {
 *  printf("Error: %s\n", c2pa_error());
 * }
 * ```
 *
 */
IMPORT extern C2paBuilder *c2pa_builder_from_json(const char *manifest_json);

/**
 * Release a C2paBuilder allocated by Rust
 * # Safety
 * can only be released once and is invalid after this call
 */
IMPORT extern void c2pa_builder_release(C2paBuilder *builder_ptr);

/**
 * Adds a resource to the C2paBuilder
 * # Errors
 * Returns -1 if there were errors, otherwise returns 0
 * The error string can be retrieved by calling c2pa_error
 * # Safety
 * Reads from null terminated C strings
 *
 */
IMPORT extern
int c2pa_builder_add_resource(C2paBuilder *builder_ptr,
                              const char *uri,
                              struct CStream *stream);

/**
 * Creates and writes signed manifest from the C2paBuilder to the destination stream
 * # Parameters
 * * builder_ptr: pointer to a Builder
 * * format: pointer to a C string with the mime type or extension
 * * source: pointer to a CStream
 * * dest: pointer to a writable CStream
 * * signer_info: pointer to a C2paSignerInfo
 * * c2pa_data_ptr: pointer to a pointer to a c_uchar (optional, can be NULL)
 * # Errors
 * Returns -1 if there were errors, otherwise returns the size of the c2pa data
 * The error string can be retrieved by calling c2pa_error
 * # Safety
 * Reads from null terminated C strings
 * If c2pa_data_ptr is not NULL, the returned value MUST be released by calling c2pa_release_string
 * and it is no longer valid after that call.
 */
IMPORT extern
int c2pa_builder_sign(C2paBuilder *builder_ptr,
                      const char *format,
                      struct CStream *source,
                      struct CStream *dest,
                      const struct C2paSignerInfo *signer_info,
                      const unsigned char **c2pa_data_ptr);

IMPORT extern
struct C2paSigner *c2pa_create_signer(CSignerCallback signer,
                                      const struct CSignerConfig *config);

/**
 * Creates a new C2paStream from context with callbacks
 *
 * This allows implementing streams in other languages
 *
 * # Arguments
 * * `context` - a pointer to a StreamContext
 * * `read` - a ReadCallback to read from the stream
 * * `seek` - a SeekCallback to seek in the stream
 * * `write` - a WriteCallback to write to the stream
 *
 * # Safety
 * The context must remain valid for the lifetime of the C2paStream
 * The resulting C2paStream must be released by calling c2pa_release_stream
 *
 */
IMPORT extern
struct CStream *c2pa_create_stream(struct StreamContext *context,
                                   ReadCallback reader,
                                   SeekCallback seeker,
                                   WriteCallback writer,
                                   FlushCallback flusher);

/**
 * Releases a CStream allocated by Rust
 *
 * # Safety
 * can only be released once and is invalid after this call
 */
IMPORT extern void c2pa_release_stream(struct CStream *stream);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* c2pa_bindings_h */
